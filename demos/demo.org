* Tutorial
** Specifying the data in one dataset

First, a trivial plot: let's plot a sinusoid

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot(np.sin(th))
#+END_SRC

#+RESULTS:
[[file:demo-1.svg]]

This was a trivial plot, and was trivially-easy to make: we called =plot()= with
one argument, and we got a plot.

Here each point we plotted was 2-dimensional (has an x value an a y value), but
we passed in only one number for each point. =gnuplotlib= saw the missing value
and filled in sequential integers (0, 1, 2, ...) for the x coordinate.

If we pass in two arrays, =gnuplotlib= will use one for the x, and the other for
the y. Let's plot =sin(theta)= vs. =cos(theta)=, i.e. a circle:

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

th = np.linspace(-np.pi, np.pi, 100)
gp.plot(np.cos(th), np.sin(th))
#+END_SRC

#+RESULTS:
[[file:demo-2.svg]]

Hmmm. We asked for a circle, but this looks more like an ellipse. Why? Because
gnuplot is autoscaling the x and y axes independently to fill the plot window.
If we ask for the autoscaling to scale the axes /together/, we get a circle:

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

th = np.linspace(-np.pi, np.pi, 100)
gp.plot(np.cos(th), np.sin(th),
        square = True)
#+END_SRC

#+RESULTS:
[[file:demo-3.svg]]

Here we used the =square= /plot option/. More on those later. We just plotted
something where each point is represented by 2 values: x and y. When making 2D
plots, this is the most common situation, but others are possible. What if we
want to color-code our points using another array to specify the colors? You
pass in the new array, you tell =gnuplotlib= that you now have /3/ values per
point (the =tuplesize=), and you tell =gnuplot= how you want this plot to be
made:

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

th = np.linspace(-np.pi, np.pi, 100)
gp.plot(np.cos(th), np.sin(th),
        # The angle (in degrees) is shown as the color
        th * 180./np.pi,
        tuplesize = 3,
        _with     = 'linespoints palette',
        square    = True)
#+END_SRC

#+RESULTS:
[[file:demo-4.svg]]

=_with= is a /curve option/ that indicates how this dataset should be plotted.
These are strings that are passed on to =gnuplot= verbatim. So the full power of
=gnuplot= is available, and there's nothing =gnuplotlib=-specific to learn.

Earlier we saw that a missing x array can be automatically filled-in with
integers 0, 1, 2, ... This is available with fancier plots also. The rule is:

- If we are given exactly =tuplesize-1= arrays, use 0, 1, 2, ... for the x

When plotting in 2D, this is the only allowed mismatch between =tuplesize= and
how much data is received. Example. Let's color-code the sinusoid by passing in
/two/ arrays. The =tuplesize= is still 3, but we have an implicit x.

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot(np.sin(th),
        # use the cosine as the color
        np.cos(th),
        tuplesize = 3,
        _with     = 'linespoints palette')
#+END_SRC

#+RESULTS:
[[file:demo-5.svg]]

Finally, so far we have been passing in each dimension in a separate array. But
it is often far more convenient to pass in a single array where each point is
represented in a row corresponding to the last dimension in that array. This is
specifiable by passing in a negative =tuplesize=. The circle plot from earlier
can be made in this way:

#+BEGIN_SRC python :python python3 :results output :session gnuplotlib-demos :exports both
import numpy      as np
import numpysane  as nps

th     = np.linspace(-np.pi, np.pi, 100)
points = nps.transpose(nps.cat(np.cos(th), np.sin(th)))

print(points.shape)
#+END_SRC

#+RESULTS:
: (100, 2)

I.e. we have 100 rows, each one of length 2.

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp

th     = np.linspace(-np.pi, np.pi, 100)
points = nps.transpose(nps.cat(np.cos(th), np.sin(th)))
gp.plot(points,
        tuplesize = -2,
        square    = True)
#+END_SRC

#+RESULTS:
[[file:demo-7.svg]]

** Specifying multiple datasets
So far we were plotting a single dataset in a plot. However, often we want to
plot multiple datasets in the same plot. Note that the code and documentation
uses the terms "dataset" and "curve" interchangeably.

As before, the whole plot is made with a single call to =plot()=. In its most
basic form, each dataset is specified as a /tuple/. /plot options/ apply to the
whole plot, and are given as kwargs to the =plot()= call. /curve options/ apply
to each dataset, and are passed as a =dict= in the last element of each dataset
tuple. So each =plot= command looks like

#+BEGIN_SRC python :exports code
plot( curve, curve, ..., plot_options )
#+END_SRC

#+RESULTS:

where each =curve= is a =tuple=:

#+BEGIN_SRC python :exports code
curve = (array, array, ..., curve_options)
#+END_SRC

#+RESULTS:

The data in each dataset is interpreted as described in the previous section.

Let's plot a sine and a cosine together, using the default styling for one, and
a specific styling for another. And let's set some common options.

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot( (
           th, np.sin(th),
         ),
         (
           th, np.cos(th),
           dict(_with  = "points pt 7",
                legend = "cosine")
         ),

         xlabel = "Angle (rad)",
         title  = "Sine and cosine",
         unset  = 'grid')
#+END_SRC

#+RESULTS:
[[file:demo-10.svg]]

The =plot()= kwargs are the plot options, but curve options are allowed there as
well. These will be used as the default curve options for all curves that omit
those specific options. For instance, if I want to plot lots of things with
lines, except /one/, I can do this:

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot( ( np.sin(th), ),
         ( np.cos(th), ),
         ( th,         ),
         ( -th, dict(_with = 'points ps 0.5') ),
         _with = 'lines')
#+END_SRC

#+RESULTS:
[[file:demo-11.svg]]

If we have just one dataset, each tuple can be inlined, which is why something
like =gp.plot(x, y)= works.

Unlike =matplotlib=, here we make a single =plot()= call instead of making a
separate call for each dataset and for each format setting. You can still
construct the plot piecemeal, however, but you'd use normal Python directives to
do that. The exact previous plot command can be generated like this:

#+BEGIN_SRC python :exports code
datasets = []

th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
datasets.append(( np.sin(th), ),)
datasets.append(( np.cos(th), ),)
datasets.append(( th,         ),)
datasets.append(( -th, dict(_with = 'points ps 0.5') ),)

plot_options = dict( _with = 'lines' )

gp.plot(*datasets, **plot_options)
#+END_SRC

#+RESULTS:

Finally, [[https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html][broadcasting]] is fully supported here, and can be used to simplify the
=plot()= call. Previously we plotted two sinusoids together using a tuple for
each dataset. With broadcasting, we can avoid that:

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot( th,
         nps.cat(np.sin(th),
                 np.cos(th)),

         legend = np.array( ("sin", "cos"), ) )
#+END_SRC

#+RESULTS:
[[file:demo-13.svg]]

I passed in an aray of shape =(100,)= for the x, and an array of shape
=(2,100,)= for the y. The broadcasting logic kicks in, and we get a plot of two
separate datasets, one for each row of y. The curve options broadcast as well:
the =legend= is expecting a scalar, but I gave it an array of shape =(2,)=, so
it uses a different legend for each of the two plotted datasets.

** Recipes





#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp

x = np.arange(21) - 10
gp.plot(( np.transpose(nps.cat(x,x**2)),
          dict(_with='linespoints pt 4 ps 2'),
         ),
        ( 5,60,
          dict(tuplesize=2,
               _with='linespoints pt 5 ps 2'),
        ),
        ( np.array((3,40)),
          dict(_with='linespoints pt 6 ps 2'),
        ),
        tuplesize = -2)
#+END_SRC

#+RESULTS:
[[file:demo-14.svg]]

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

x = np.arange(21) - 10
gp.plot(-x, x**3)
#+END_SRC

#+RESULTS:
[[file:demo-15.svg]]

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

x = np.arange(21) - 10
gp.plot((x**2))
#+END_SRC

#+RESULTS:
[[file:demo-16.svg]]

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

x = np.arange(21) - 10
gp.plot((-x, x**3, dict(_with = 'lines')), (x**2,))
#+END_SRC

#+RESULTS:
[[file:demo-17.svg]]

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp

x = np.arange(21) - 10
gp.plot( x, nps.cat(x**3, x**2) )
#+END_SRC

#+RESULTS:
[[file:demo-18.svg]]

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp

x = np.arange(21) - 10
gp.plot( nps.cat(-x**3, x**2), _with='lines' )
#+END_SRC

#+RESULTS:
[[file:demo-19.svg]]

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp

x = np.arange(21) - 10
gp.plot( (nps.cat(x**3, -x**2), dict(_with = 'points') ))
#+END_SRC

#+RESULTS:
[[file:demo-20.svg]]

Make sure xrange settings don't get overridden. The label below should be out of
bounds, and not visible

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

gp.plot( ( np.arange(10), ),
         ( np.array((5,),), np.array((2,),), np.array(("Seeing this is a bug!",),),
           dict(_with = 'labels',
                tuplesize = 3)),
         ( np.array((5,),), np.array((7,),), np.array(("This SHOULD be visible. Another label should be out-of-view, below the x-axis",),),
           dict(_with = 'labels',
                tuplesize = 3)),
         _set  = 'yrange [5:10]',
         unset = 'grid')
#+END_SRC

#+RESULTS:
[[file:demo-21.svg]]

some more varied plotting, using the object-oriented interface

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp

x = np.arange(21) - 10
plot1 = gp.gnuplotlib(_with = 'linespoints',
                      xmin  = -10,
                      title = 'Error bars and other things',)

plot1.plot( ( nps.cat(x, x*2, x*3), x**2 - 300,
              dict(_with  = 'lines lw 4',
                   y2     = True,
                   legend = 'parabolas')),

            (x**2 * 10, x**2/40, x**2/2, # implicit domain
             dict(_with      =      'xyerrorbars',
                  tuplesize = 4)),

            (x, nps.cat(x**3, x**3 - 100),
             dict(_with     = 'lines',
                  legend    = 'shifted cubics',
                  tuplesize = 2)))
#+END_SRC

#+RESULTS:
[[file:demo-22.svg]]

a way to control the point size

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

x = np.arange(21) - 10
gp.plot( x**2, np.abs(x)/2, x*50,
         cbrange = '-600:600',
         _with   = 'points pointtype 7 pointsize variable palette',
         tuplesize = 4,)
#+END_SRC

#+RESULTS:
[[file:demo-23.svg]]

labels

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

x = np.arange(21) - 10
gp.plot(np.arange(5),np.arange(5)+1,
        np.array( ['{} {}'.format(x,x+1) for x in range(5)], dtype=str),
        _with='labels', tuplesize=3, ascii=1,)
#+END_SRC

#+RESULTS:
[[file:demo-24.svg]]

Conchoids of de Sluze. Broadcasting example

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

rho = np.linspace(0, 2*np.pi, 1000)  # dim=(  1000,)
a   = np.arange(-4,3)[:, np.newaxis] # dim=(7,1)

gp.plot( rho,
         1./np.cos(rho) + a*np.cos(rho), # broadcasted. dim=(7,1000)

         _with  = 'lines',
         set    = 'polar',
         square = True,
         yrange = [-5,5],
         legend = a.ravel(),)
#+END_SRC

#+RESULTS:
[[file:demo-25.svg]]


some 3d stuff

gp.plot a sphere

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

th = np.linspace(0,        np.pi*2, 30)
ph = np.linspace(-np.pi/2, np.pi*2, 30)[:,np.newaxis]
x  = (np.cos(ph) * np.cos(th))          .ravel()
y  = (np.cos(ph) * np.sin(th))          .ravel()
z  = (np.sin(ph) * np.ones( th.shape )) .ravel()

gp.plot3d( x, y, z,
           _with = 'points',
           title  = 'sphere',
           square = True,
           legend = 'sphere',)
#+END_SRC

#+RESULTS:
[[file:demo-26.svg]]

sphere, ellipse together

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp

th = np.linspace(0,        np.pi*2, 30)
ph = np.linspace(-np.pi/2, np.pi*2, 30)[:,np.newaxis]
x  = (np.cos(ph) * np.cos(th))          .ravel()
y  = (np.cos(ph) * np.sin(th))          .ravel()
z  = (np.sin(ph) * np.ones( th.shape )) .ravel()

gp.plot3d( (x * nps.transpose(np.array([[1,2]])),
            y * nps.transpose(np.array([[1,2]])),
            z,
            dict( legend = np.array(('sphere', 'ellipse')))),

           title  = 'sphere, ellipse',
           square = True,
           _with  = 'points',)
#+END_SRC

#+RESULTS:
[[file:demo-27.svg]]

similar, written to a png

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp

th = np.linspace(0,        np.pi*2, 30)
ph = np.linspace(-np.pi/2, np.pi*2, 30)[:,np.newaxis]
x  = (np.cos(ph) * np.cos(th))          .ravel()
y  = (np.cos(ph) * np.sin(th))          .ravel()
z  = (np.sin(ph) * np.ones( th.shape )) .ravel()

gp.plot3d( (x * nps.transpose(np.array([[1,2]])),
            y * nps.transpose(np.array([[1,2]])),
            z,
            dict( legend = np.array(('sphere', 'ellipse')))),

           title    = 'sphere, ellipse',
           square   = True,
           _with    = 'points',)
#+END_SRC

#+RESULTS:
[[file:demo-28.svg]]

some paraboloids plotted on an implicit 2D domain

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

xx,yy = np.mgrid[-10:11, -10:11]
zz    = xx*xx + yy*yy

gp.plot3d( ( zz,  dict(legend = 'zplus')),
           (-zz,  dict(legend = 'zminus')),
           (zz*2, dict(legend = 'zplus2')),

           _with = 'points', title  = 'gridded paraboloids', ascii=True,)
#+END_SRC

#+RESULTS:
[[file:demo-29.svg]]

3d, variable color, variable pointsize

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp

th    = np.linspace(0, 6*np.pi, 200)
z     = np.linspace(0, 5,       200)
size  = 0.5 + np.abs(np.cos(th))
color = np.sin(2*th)

gp.plot3d( ( np.cos(th) * nps.transpose(np.array([[1,-1]])),
             np.sin(th) * nps.transpose(np.array([[1,-1]])),
             z, size, color, dict( legend = np.array(('spiral 1', 'spiral 2')))),

           title     = 'double helix',
           tuplesize = 5,
           _with = 'points pointsize variable pointtype 7 palette',
           squarexy = True)
#+END_SRC

#+RESULTS:
[[file:demo-30.svg]]

implicit domain heat map

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

xx,yy = np.mgrid[-10:11, -10:11]
zz    = xx*xx + yy*yy

gp.plot3d(zz,
          title = 'Paraboloid heat map',
          set   = ('view equal xy', 'view 0,0'),
          _with = 'image')
#+END_SRC

#+RESULTS:
[[file:demo-31.svg]]

same, but as a 2d gp.plot, _with a curve drawn on top for good measure

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

x2 = np.linspace(0,20,100)
xx,yy = np.mgrid[-10:11, -10:11]
zz    = xx*xx + yy*yy

gp.plot( ( zz, dict(tuplesize = 3,
                    _with     = 'image')),
         (x2, 20*np.cos(x2/20 * np.pi/2),

          dict(tuplesize = 2,
               _with     = 'lines')),

         title  = 'Paraboloid heat map, 2D',
         square = True,
         xmin   = 0,
         xmax   = 20,
         ymin   = 0,
         ymax   = 20,)
#+END_SRC

#+RESULTS:
[[file:demo-32.svg]]

2D implicit domain demos

single 3d matrix curve

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

gp.plot(zz,
        title     = 'Single 3D matrix plot. Binary.',
        square    = 1,
        tuplesize = 3,
        _with     = 'points palette pt 7',
        ascii     = False,)
#+END_SRC

#+RESULTS:
[[file:demo-33.svg]]

4d matrix curve

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

xx,yy = np.mgrid[-10:11, -8:2]
zz = np.sqrt(xx*xx + yy*yy)

gp.plot(zz / 5., xx,
        title     = '4D matrix plot. Binary.',
        square    = 1,
        tuplesize = 4,
        _with     = 'points palette ps variable pt 7',
        ascii     = False,)
#+END_SRC

#+RESULTS:
[[file:demo-34.svg]]

Using broadcasting to plot each slice with a different style

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp

xx,yy = np.mgrid[-10:11, -8:2]
zz = np.sqrt(xx*xx + yy*yy)

gp.plot((nps.cat(xx,zz / 5.),
         dict(tuplesize = 3,
              _with     = np.array(('points palette pt 7','points ps variable pt 6')))),

        title  = 'Two 3D matrix plots. Binary.',
        square = 1,
        ascii  = False,)
#+END_SRC

#+RESULTS:
[[file:demo-35.svg]]

2 3d matrix curves
#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp

xx,yy = np.mgrid[-10:11, -8:2]
zz = np.sqrt(xx*xx + yy*yy)

gp.plot( nps.cat(xx,zz / 5.),
        tuplesize = 3,
        _with     = np.array(('points palette pt 7','points ps variable pt 6')),
        title  = 'Two 3D matrix plots. Binary.',
        square = 1)
#+END_SRC

#+RESULTS:
[[file:demo-36.svg]]

fancy contours just because I can

single 3d matrix curve. Two plots: the image and the contours together.
Broadcasting the styles

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

yy_big,xx_big = np.mgrid[0:61,0:61]
xx_big -= 30
yy_big -= 30
zz_big = np.sin(xx_big / 4.0) * yy_big

gp.plot3d( (zz_big, dict(tuplesize = 3,
                     _with     = np.array(('image','lines')))),

           title = 'matrix plot with contours',
           cmds  = [ 'set contours base',
                     'set cntrparam bspline',
                     'set cntrparam levels 15',
                     'unset grid',
                     'unset surface',
                     'set view 0,0'],
           square = 1,)
#+END_SRC

#+RESULTS:
[[file:demo-37.svg]]

multiplot

basics

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp

th = np.linspace(0, np.pi*2, 30)
gp.plot( th, nps.cat( np.cos(th), np.sin(th)),
         title = 'broadcasting sin, cos',
         _xrange = [0,2.*np.pi],
         _yrange = [-1,1],)
#+END_SRC

#+RESULTS:
[[file:demo-38.svg]]

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

th = np.linspace(0, np.pi*2, 30)
gp.plot( (th, np.cos(th)),
         (th, np.sin(th)),
         title = 'separate plots for sin, cos',
         _xrange = [0,2.*np.pi],
         _yrange = [-1,1],)
#+END_SRC

#+RESULTS:
[[file:demo-39.svg]]

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

th = np.linspace(0, np.pi*2, 30)
gp.plot( (th, np.cos(th), dict(title="cos",
                               _xrange = [0,2.*np.pi],
                               _yrange = [-1,1],)),
         (th, np.sin(th), dict(title="sin",
                               _xrange = [0,2.*np.pi],
                               _yrange = [-1,1])),
         multiplot='title "multiplot sin,cos" layout 2,1',)
#+END_SRC

#+RESULTS:
[[file:demo-40.svg]]

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

rho  = np.linspace(0, 2*np.pi, 1000)  # dim=(  1000,)
a    = np.arange(-4,3)[:, np.newaxis] # dim=(7,1)
th   = np.linspace(0,        np.pi*2, 30)
ph   = np.linspace(-np.pi/2, np.pi*2, 30)[:,np.newaxis]
x_3d = (np.cos(ph) * np.cos(th))          .ravel()
y_3d = (np.cos(ph) * np.sin(th))          .ravel()
z_3d = (np.sin(ph) * np.ones( th.shape )) .ravel()

gp.plot( (x**2,),
         (-x, x**3),
         ( rho,
           1./np.cos(rho) + a*np.cos(rho), # broadcasted. dim=(7,1000)

           dict( _with  = 'lines',
                 set    = 'polar',
                 square = True,
                 yrange = [-5,5],
                 legend = a.ravel())),
         (x_3d, y_3d, z_3d,
          dict( _with = 'points',
                title  = 'sphere',
                square = True,
                legend = 'sphere',
                _3d    = True)),
         multiplot='title "basic multiplot" layout 2,2', )
#+END_SRC

#+RESULTS:
[[file:demo-41.svg]]

fancy contours stacked on top of one another. Using multiplot to render
several plots directly onto one another

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-demos :exports both
import numpy      as np
import gnuplotlib as gp

xx,yy = np.meshgrid(np.linspace(-5,5,100),
                    np.linspace(-5,5,100))
zz0 = np.sin(xx) + yy*yy/8.
zz1 = np.sin(xx) + yy*yy/10.
zz2 = np.sin(xx) + yy*yy/12.

commonset = ( 'origin 0,0',
              'size 1,1',
              'view 60,20,1,1',
              'xrange [0:100]',
              'yrange [0:100]',
              'zrange [0:150]',
              'contour base' )
gp.plot3d( (zz0, dict(_set = commonset + ('xyplane at 10',))),
           (zz1, dict(_set = commonset + ('xyplane at 80',  'border 15'), unset=('ztics',))),
           (zz2, dict(_set = commonset + ('xyplane at 150', 'border 15'), unset=('ztics',))),

           tuplesize=3,
           _with = np.array(('lines nosurface',
                             'labels boxed nosurface')),
           square=1,
           multiplot=True)
#+END_SRC

#+RESULTS:
[[file:demo-42.svg]]

* init                                                             :noexport:
Local Variables:
eval: (progn
          (setq org-confirm-babel-evaluate nil)
          (org-babel-do-load-languages
           'org-babel-load-languages
            '((python  . t)))
;; This is all very convoluted. There are 3 different advices, commented in
;; place
;;
;; THIS advice makes all the org-babel parameters available to python in the
;; _org_babel_params dict. I care about _org_babel_params['_file'] specifically,
;; but everything is available
(defun dima-org-babel-python-var-to-python (var)
  "Convert an elisp value to a python variable.
  Like the original, but supports (a . b) cells and symbols
"
  (if (listp var)
      (if (listp (cdr var))
          (concat "[" (mapconcat #'org-babel-python-var-to-python var ", ") "]")
        (format "\"\"\"%s\"\"\"" var))
    (if (symbolp var)
        (format "\"\"\"%s\"\"\"" var)
      (if (eq var 'hline)
          org-babel-python-hline-to
        (format
         (if (and (stringp var) (string-match "[\n\r]" var)) "\"\"%S\"\"" "%S")
         (if (stringp var) (substring-no-properties var) var))))))
(defun dima-alist-to-python-dict (alist)
  "Generates a string defining a python dict from the given alist"
  (let ((keyvalue-list
         (mapcar (lambda (x)
                   (format "%s = %s, "
                           (replace-regexp-in-string
                            "[^a-zA-Z0-9_]" "_"
                            (symbol-name (car x)))
                           (dima-org-babel-python-var-to-python (cdr x))))
                 alist)))
    (concat
     "dict( "
     (apply 'concat keyvalue-list)
     ")")))
(defun dima-org-babel-python-pass-all-params (f params)
  (cons
   (concat
    "_org_babel_params = "
    (dima-alist-to-python-dict params))
   (funcall f params)))
(unless
    (advice-member-p
     #'dima-org-babel-python-pass-all-params
     #'org-babel-variable-assignments:python)
  (advice-add
   #'org-babel-variable-assignments:python
   :around #'dima-org-babel-python-pass-all-params))
;; This sets a default :file tag, set to a unique filename. I want each demo to
;; produce an image, but I don't care what it is called. I omit the :file tag
;; completely, and this advice takes care of it
(defun dima-org-babel-python-unique-plot-filename
    (f &optional arg info params)
  (funcall f arg info
           (cons (cons ':file
                       (format "demo-%d.svg"
                               (condition-case nil
                                   (setq dima-unique-plot-number (1+ dima-unique-plot-number))
                                 (error (setq dima-unique-plot-number 0)))))
                 params)))
(unless
    (advice-member-p
     #'dima-org-babel-python-unique-plot-filename
     #'org-babel-execute-src-block)
  (advice-add
   #'org-babel-execute-src-block
   :around #'dima-org-babel-python-unique-plot-filename))
;; If I'm regenerating ALL the plots, I start counting the plots from 0
(defun dima-reset-unique-plot-number
    (&rest args)
    (setq dima-unique-plot-number 0))
(unless
    (advice-member-p
     #'dima-reset-unique-plot-number
     #'org-babel-execute-buffer)
  (advice-add
   #'org-babel-execute-buffer
   :after #'dima-reset-unique-plot-number))
;; I'm using github to display demo.org, so I'm not using the "normal" org
;; exporter. I want the demo text to not contain the hardcopy= tags, but clearly
;; I need the hardcopy tag when generating the plots. I add some python to
;; override gnuplotlib.plot() to add the hardcopy tag somewhere where the reader
;; won't see it. But where to put this python override code? If I put it into an
;; org-babel block, it will be rendered, and the :export tags will be ignored,
;; since github doesn't respect those (probably). So I put the extra stuff into
;; an advice. Whew.
(defun dima-org-babel-python-set-demo-output (f body params)
  (with-temp-buffer
    (insert body)
    (beginning-of-buffer)
    (when (search-forward "import gnuplotlib as gp" nil t)
      (end-of-line)
      (insert
       "\n"
       "if not hasattr(gp.gnuplotlib, 'orig_init'):\n"
       "    gp.gnuplotlib.orig_init = gp.gnuplotlib.__init__\n"
       "gp.gnuplotlib.__init__ = lambda self, *args, **kwargs: gp.gnuplotlib.orig_init(self, *args, hardcopy=_org_babel_params['_file'] if 'file' in _org_babel_params['_result_params'] else None, **kwargs)\n"))
    (setq body (buffer-substring-no-properties (point-min) (point-max))))
  (funcall f body params))

(unless
    (advice-member-p
     #'dima-org-babel-python-set-demo-output
     #'org-babel-execute:python)
  (advice-add
   #'org-babel-execute:python
   :around #'dima-org-babel-python-set-demo-output))
)
End:


* tocover

** styling
** recipes
3d
histograms
contours
polar

3d. missing 2. image

title
xlabels
autolegend
xrange
